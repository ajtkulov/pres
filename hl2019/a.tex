\documentclass[aspectratio=169]{beamer}

\usepackage[russian]{babel}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[cp1251]{inputenc}
% \usepackage[utf8]{inputenc}
\usepackage{epigraph}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{verbatimbox}
\usepackage{pgfplots}
\pgfplotsset{width=10cm,height=6cm,compat=1.3}

\usepgflibrary{arrows}


\usetheme{Madrid}

\newcommand*{\sele}[1]{{\bf #1}}
\newcommand*{\sel}[1]{\textcolor{blue}{#1}}
\newcommand*{\prob}[1]{\textcolor{magenta}{#1}}
\newcommand*{\vs}[0]{\vspace{10pt}}
\newcommand<>{\fullsizegraphic}[1]{
%  \begin{textblock*}{0cm}(-1cm,-3.78cm)
  \includegraphics[width={\paperwidth}]{#1}
%  \end{textblock*}
}

\title[Вероятностные структуры данных]{Кое-что о вероятностных структурах данных}
\author{Pavel Ajtkulov}
\institute[]{ajtkulov@gmail.com, piano.io}
\date{6-7 ноября 2019 г.}

\begin{document}

\frame{\titlepage}



\frame
{
\frametitle{Обо мне}

\begin{itemize}
  \item data engineer
  \item scala, fp, reasonable fp
  \item спортивное ЧГК (Puzzle, top 250)
  \item шахматы (Elo = 1950..2000)
  \item бег (марафон: 3h 57m, $\frac{1}{2}$ марафон: 1h 43m, 10k: 45m 40s)
\end{itemize}


}


\frame
{
\frametitle{Чего не будет в этом докладе}


\begin{itemize}
  \item TCS
  \item skip list
  \item treap
  \item Monte Carlo
  \item Local sensevity hashing
  \item etc.
\end{itemize}


}

\frame
{
\frametitle{Что будет в этом докладе}


Вероятностные структуры данных, которые позволяют экономить память.

\vspace{5mm}


Данных много. 

Храним мало, либо очень мало. 

\vspace{5mm}

Очень ограниченные задачи. 

Шаг вправо, шаг влево - попытка к бегству! Стреляем без предупреждения!

\vspace{5mm}

Немного CS, базовая теория вероятности.
}




\frame
{
\frametitle{Предупреждение}

\epigraph{Надежность - это когда вашу программу ставят на военную технику, а вы спите спокойно}{\textit{Н. Н. Непейвода}}

\vspace{5mm}

Примечение: если от вашего кода зависит человеческая жизнь - одумайтесь.

}

\frame
{
\frametitle{Главное - не терять голову}

      \begin{figure}
        \includegraphics[height=0.55\textwidth]{killbill.jpg}
      \end{figure}
}


\frame
{
\frametitle{HyperLogLog}

\begin{center}
{\huge HyperLogLog}
\end{center}
}

\frame
{
\frametitle{Задача}


\colorbox{gray!30}{select count(distinct(field)) from table}

\vspace{5mm}

От 10M, лучше от 100M. Eще больше. Значительно.

Иначе можно решаеть классическими способами.
}



\frame
{
\frametitle{Идеальный мир}

Рассмотрим минимальный hash.

\vspace{5mm}

\colorbox{gray!30}{obj1, obj2, obj3, obj4, \ldots}

\vspace{5mm}


\colorbox{gray!30}{0.672, 0.368, 0.864, 0.782, \ldots}

\vspace{5mm}

Встретить 0.368 "более вероятно" чем 0.000001 (на 5-10 элементах).
}



\begin{frame}[fragile]
\frametitle{Внутренности}

Применим "шардинг" (простой roundRobin), будем считать min-hash для каждого подпотока.

  \begin{verbatim}
          a1, aN+1, ...         minHash
stream -> a2                    minHash
          ...                   ...
          aN                    minHash

  \end{verbatim}

\pause

Internal Representation: Array[Int]

\end{frame}

\begin{frame}[plain]

      \begin{figure}
        \includegraphics[height=0.8\textwidth]{hll_paper.png}
      \end{figure}
\end{frame}


\begin{frame}[plain]

      \begin{figure}
        \includegraphics[height=0.5\textwidth]{cocain.jpg}
      \end{figure}
\end{frame}



\frame
{
\frametitle{Random facts}

Не BTC, но тоже нули. Log. LogLog.
$$0.000001010111 \mapsto 5$$

Набор предрасчитанных магических констант.

Где используется: 
во многих базах данных($redis,\ redshift,\ google\ bigquery$).

\vspace{5mm}

\colorbox{gray!30}{$select\ approx\_count(distinct(field))\ from\ table$}

\vspace{5mm}

The HyperLogLog algorithm is able to estimate cardinalities of $> 10^9$ with a typical accuracy (standard error) of $2\%$, using 1.5 kB of memory. (original paper, wiki)

\vspace{5mm}

Распределенный подсчет HyperLogLog. 

}

\frame
{
\frametitle{Stats}
      \begin{figure}
        \includegraphics[height=0.475\textwidth]{hll_stats.png}
      \end{figure}

}


\begin{frame}[fragile]

\frametitle{Нужно ли где-то в простой жизни?}

Сетевое оборудование, считать количество уникальных src/dest соединений. 
Малое количество памяти, большое число объектов. 
Определение DDOS, "нечисти".

\pause

{\color{blue}
\begin{verbatim}
  stream, stream, stream, stream, ...

    [ new HLL ]
        [ new HLL ]
            [ new HLL ]

    -------------time>>
    [  ]        -  5 min
    [         ] - 30 min

\end{verbatim}
}

\pause

Если вы работаете в FAANG, \ldots

\end{frame}


\frame
{
\frametitle{Bloom filter}

\begin{center}
{\huge Bloom filter}
\end{center}
}


\frame
{
\frametitle{Задача}

На {\color{blue}<<мобильный телефон>>} поступает {\color{blue}<<входящий звонок>>}. Проверить, что {\color{blue}<<номера абонента>>} нет в {\color{blue}<<базе спаммеров>>}, без тяжелого запроса в {\color{blue}<<сторонние сервисы>>}.

\vspace{5mm}

\pause

{\color{blue} Абстракция: база данных/запрос/кэш/чтение с диска.}

\vspace{5mm}

\pause

Только ответ да/нет.

\vspace{5mm}

\pause

Задача перечисления, порядок добавления, возможность удаления сюда не входит.

\vspace{5mm}

Если объектов немного, то классика.
}

\begin{frame}[fragile]
\frametitle{Разогрев}

Есть hashTable с 10 слотами, вставляем 3 объекта. С какой вероятностью будут коллизии?

\pause

\vspace{5mm}

{\color{blue}
\begin{verbatim}
[ ] [ ] [*] [ ] [*] [ ] [*] [*] [ ] [ ]

vs.

[ ] [ ] [*] [ ] [*] [ ] [*] [ ] [ ] [ ]
         *
\end{verbatim}
}

\end{frame}

\begin{frame}[plain]

      \begin{figure}
        \includegraphics[height=0.5\textwidth]{tick1.jpg}
      \end{figure}
\end{frame}

\begin{frame}[plain]

      \begin{figure}
        \includegraphics[height=0.63\textwidth]{tick2.jpg}
      \end{figure}
\end{frame}


\frame
{
\frametitle{Разогрев}

Легко видеть что $\textsuperscript{\textcopyright}$:
$$1$$

\pause 

$$1 * (9 / 10)$$

\pause 

$$1 * (9 / 10) * (8 / 10)$$

\pause 

$$1 - 1 * (9 / 10) * (8 / 10) = 1 - 0.72 = 0.28$$




Да, это та же задача что и в парадоксе дней рождения. 

\pause

\vspace{5mm}

Лайфхак: функция растет как $sqrt(n)$. 

Посчитать для int32, int64.

}

\frame
{
\frametitle{Идеальный мир}

Коллизии отсутствуют и бесконечная память.

\vspace{5mm}

Тогда бы хранили битовый флаг на бесконечной ленте. 
}

\frame
{
\frametitle{Реальность, несколько хеш-функций}

\begin{center}
\onslide<1, 2>
\begin{tikzpicture}[scale=0.036]
\draw[gray, thick] (0, 0) -- (360, 0);
\node[gray] at (10,30) {$\{\}$}; 
\draw[gray, thick] (0, 20) -- (360, 20);
\foreach \x in {0,...,18}
 \draw[gray, thick] (20 * \x, 20) -- (20 * \x, 0);
\end{tikzpicture}

\onslide<2, 3>
\begin{tikzpicture}[scale=0.036]
\draw[gray, thick] (0, 0) -- (360, 0);
\draw[gray, thick] (0, 20) -- (360, 20);
\foreach \x in {0,...,18}
 \draw[gray, thick] (20 * \x, 20) -- (20 * \x, 0);
\node[blue] at (10,30) {$\{x\}$}; 
\node[blue] at (30,10) {1}; 
\node[blue] at (110,10) {1}; 
\node[blue] at (270,10) {1}; 
\end{tikzpicture}

\onslide<3, 4>
\begin{tikzpicture}[scale=0.036]
\draw[gray, thick] (0, 0) -- (360, 0);
\draw[gray, thick] (0, 20) -- (360, 20);
\foreach \x in {0,...,18}
 \draw[gray, thick] (20 * \x, 20) -- (20 * \x, 0);
\node[blue] at (10,30) {$\{x\}$}; 
\node[red] at (30,30) {$\{y\}$}; 
\node[blue] at (30,10) {1}; 
\node[blue] at (110,10) {1}; 
\node[blue] at (270,10) {1}; 
\node[red] at (90,10) {1}; 
\node[red] at (230,10) {1}; 
\node[red] at (330,10) {1}; 

\end{tikzpicture}

\onslide<4, 5>
\begin{tikzpicture}[scale=0.036]
\draw[gray, thick] (0, 0) -- (360, 0);
\draw[gray, thick] (0, 20) -- (360, 20);
\foreach \x in {0,...,18}
 \draw[gray, thick] (20 * \x, 20) -- (20 * \x, 0);
\node[blue] at (10,30) {$\{x\}$}; 
\node[red] at (30,30) {$\{y\}$}; 
\node[violet] at (50,30) {$\{z\}$}; 
\node[blue] at (30,10) {1}; 
\node[blue] at (110,10) {1}; 
\node[blue] at (270,10) {1}; 
\node[red] at (90,10) {1}; 
\node[red] at (230,10) {1}; 
\node[red] at (330,10) {1}; 
\node[violet] at (70,10) {1}; 
\node[violet] at (110,10) {1}; 
\node[violet] at (230,10) {1}; 

\end{tikzpicture}


\onslide<5>
\begin{tikzpicture}[scale=0.036]
\draw[gray, thick] (0, 0) -- (360, 0);
\draw[gray, thick] (0, 20) -- (360, 20);
\foreach \x in {0,...,18}
 \draw[gray, thick] (20 * \x, 20) -- (20 * \x, 0);
\node at (10,30) {$\{x\}$}; 
\node at (30,30) {$\{y\}$}; 
\node at (50,30) {$\{z\}$}; 
\node at (30,10) {1}; 
\node at (110,10) {1}; 
\node at (270,10) {1}; 
\node at (90,10) {1}; 
\node at (230,10) {1}; 
\node at (330,10) {1}; 
\node at (70,10) {1}; 
\node at (110,10) {1}; 
\node at (230,10) {1}; 

\end{tikzpicture}

\end{center}

}

\frame
{
\frametitle{Реальность, несколько хеш-функций}


      \begin{figure}
        \includegraphics[height=0.3\textwidth]{bloom.png}
      \end{figure}


Проверка.  Только False Positive.

Нельзя удалять.

Confusion matrix.
}

\begin{frame}[fragile]
\frametitle{Confusion matrix}

\begin{verbatim}
*---------------*---------------*         
| TruePositive  | FalsePositive |             140 |   113
*---------------*---------------*            -----*------- 
| FalseNegative | TrueNegative  |               8 | 21414
*---------------*---------------*


157414 |       7
-------*---------
     0 | 6837254

error = 10^{-6}

\end{verbatim}





\end{frame}

\begin{frame}[plain]

      \begin{figure}
        \includegraphics[height=0.65\textwidth]{bloom_wiki.png}
      \end{figure}
\end{frame}


\frame
{
\frametitle{Посчитаем}

Оказывается, не все так плохо. На каждые $10^{-3}$ ошибки требуется примерно 10 бит (бит, не байтов!).
То есть на $10^{-6}$ - 20 бит (2.5 байта), $10^{-9}$ - 30 бит (3.75 байта, все еще меньше одного указателя), и так далее.
Объекты - довольно жирные.

\vspace{5mm}

Внутри это всего лишь bitset. Нет никакого memory footprint.

\vspace{5mm}

То есть на 100M объектов с ошибкой $10^{-6}$ требуется 250Мб памяти.

\vspace{5mm}

"Минусы": исходная постановка урезана, нет "честной" возможности удалять, перечислять объекты.
}

\frame
{
\frametitle{Честность и относительность}


Удалять - завести второй bloomFilter, для удаленных. Делать 2 запроса. 

\vspace{5mm}

Нельзя "честно" удалить, а потом снова добавить.

\vspace{5mm}

Можно... Вы поняли идею
}


\frame
{
\frametitle{Combine}

$$bloom_1 + bloom_2 = bitOr (bloom_1.bitset, bloom_2.bitset)$$

$$bloom_1 * bloom_2 = bitAnd (bloom_1.bitset, bloom_2.bitset)$$

Spark example. 

$$Partition.map(x => Bloom(\ldots)).reduce(\_ + \_)$$
$$Partition.map(x => Bloom(\ldots)).reduce((x, y) => x + y)$$

Обратная задача. По bloomFilter понять сколько там элементов. 

Конструктор: (количество уникальных элементов, ошибка)

}

\frame
{
\frametitle{Bloom filter, use cases}

\begin{center}
{\huge Bloom filter, use cases}
\end{center}
}


\frame
{
\frametitle{Key-value storage}


Если кардинальность значений не велика $(k \le 10)$, то можно хранить $k$ bloom filter-ов. 
Спросить каждый. Учитывать, что ошибка меняется (* k).

}


\frame
{
\frametitle{Key-value storage}

Если кардинальность значений велика $(k > 10)$, то можно хранить $k$ bloom filter-ов.
Организовать дерево на них. 

\pause

\vspace{5mm}

На самом деле, это сложнее. Так как необходимо контролировать размеры и ошибку.
На домашнее задание.


      \begin{figure}
        \includegraphics[height=0.3\textwidth]{btree.png}
      \end{figure}


}


\frame
{
\frametitle{Телефонная база спамеров}

$+7-909-052-xx-yy$

\vspace{5mm}

Хранить на телефоне. 

\vspace{5mm}

В Int32 не влазит. Нужно отвечать да/нет в период звонка (до принятия). 
Гипотетически, $10^6$ <<плохих>> номеров.

\vspace{5mm}
Создать bloomFilter с ошибкой $p=10^{-9}$. Пробежаться во всему пространству номеров телефонов и явно выписать false Positive объекты.

\vspace{5mm}

На таких ограничениях есть много решений.
}


\frame
{
\frametitle{Trie}

Trie (цифровое дерево, префиксное дерево) - структура данных, хранящая префиксы слов.
Позволяет искать вхождение и слова с заданным числом отпечаток.


      \begin{figure}
        \includegraphics[height=0.3\textwidth]{trie.png}
      \end{figure}

\vspace{5mm}

<<ключ>>, <<ключница>>
}



\frame
{
\frametitle{Trie}

Предлагается хранить все префискы слов в bloomFilter. Все итоговые слова еще в одном bloomFilter.



В trie это обычно хранится булевым флагом, признак конца слова.

Чтобы спуститься на уровень вниз - переберем алфавит (либо доп. структуру, хранящую возможные переходы)

Оценка

Здесь же мы тратим 20-30 бит (1.5 - 3.75 байта) на узел.
}


\frame
{
\frametitle{Где используется в мире}

Почти в любом кеше и базе данных. Проще проверить в bloomFilter, и только потом читать с диска / делать тяжелый запрос.

Google guava (jvm).
TODO: обзор библиотек

TODO: compressed bloom filter
}

\frame
{
\frametitle{Count min sketch}

Задача: 
\colorbox{gray!30}{select count(*) from table where object = N}
}

\frame
{
\frametitle{Count min sketch}

\begin{center}
{\huge Count min sketch}
\end{center}
}


\frame
{
\frametitle{Count min sketch}


      \begin{figure}
        \includegraphics[height=0.3\textwidth]{mins.png}
      \end{figure}

\pause

$$query = min_{i \in 1 \ldots k}(t_i(h_i))$$



}

\frame
{
\frametitle{Count min sketch}

Проблема перекоса данных, когда все ячейки в матрицы > 0.

Merge двух

Поэлементно сложить внутренний массив.

TODO: параметры конструктора, память.

}








\frame
{
\frametitle{Desing, likes}

Пользователей - $10^9$, объектов - $10^9$. 

Всегда работает грубая сила "мы купили кластер на $100 - 1 K - 10 K$ нод и храним все".

Лайк - $(user_id, object_id)$. 

Да, bloomFilter на факт лайка/дизлайка. 

Количество лайков - классический KV, либо $Count-min-sketch(object_id)$.

Шардинг по $object_id, (user_id, object_id)$

Кто из друзей так же лайкал? Пробежаться по списку друзей, спросить bloomFilter.
Естественный граф ($natural\ graph$), особенности.

Отложенный лайк, если пользователь быстро передумал или промахнулся.
}


\frame
{
\frametitle{Desing, views}

Много объявлений (<<Avito>>), много пользователей. Хотим видеть общее количество уникальных просмотров, просмотров за 
час/день/неделю/месяц. 

\pause

\vspace{5mm}

Храним BloomFilter для (user.id, item.id), смотрел ли вообще конкретный человек конкретное объявление. Глобальный. Это и есть количество уникальных. 

Инкрементируем просмотры в Count min sketch, на каждый квант времени (час) - отдельный. 
Их можно складывать/вычитать, организовать sliding window. В качестве ключа использовать item.id, можно расширенный (user.id, item.id).




}


\frame
{
\frametitle{Random facts}

TODO: обзор библиотек

Quotient filter (a bit stronger than Bloom filter)

Абсолютная точность редко нужна, чаще нужен порядок. $67\ 108\ 864\ vs.\ 67.1M$

}






\begin{frame}[plain]

      \begin{figure}
        \includegraphics[height=0.8\textwidth]{theend.jpg}
      \end{figure}
\end{frame}


\frame
{
\frametitle{Q. E. D.}

Спасибо!

\vspace{5mm}

$!?$

\vspace{5mm}

Можете задавать любые вопросы, но отвечу я вероятностно.

\vspace{5mm}

$\blacksquare$

}






\end{document}
