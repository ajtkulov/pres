\documentclass{beamer}

\usepackage[russian]{babel}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage[cp1251]{inputenc}
%\usepackage[utf8]{inputenc}
\usepackage{epigraph}
\usepackage{tikz}

\usepackage{pgfplots}
\pgfplotsset{width=10cm,height=6cm,compat=1.3}

\usepgflibrary{arrows}


\usetheme{Madrid}

\newcommand*{\sele}[1]{{\bf #1}}
\newcommand*{\sel}[1]{\textcolor{blue}{#1}}
\newcommand*{\prob}[1]{\textcolor{magenta}{#1}}
\newcommand*{\vs}[0]{\vspace{10pt}}
\newcommand<>{\fullsizegraphic}[1]{
%  \begin{textblock*}{0cm}(-1cm,-3.78cm)
  \includegraphics[width={\paperwidth}]{#1}
%  \end{textblock*}
}

\title[Вероятностные структуры данных]{Кое-что о вероятностных структурах данных}
\author{Pavel Ajtkulov}
\institute[]{piano.io}
\date{6-7 ноября 2019 г.}

\begin{document}

\frame{\titlepage}



\frame
{
\frametitle{Обо мне}

\begin{itemize}
  \item data engineer
  \item scala, fp, reasonable fp
  \item спортивное ЧГК (Puzzle, top 200-250)
  \item шахматы (Elo = 1950..2000)
  \item бег (марафон: 3h 57m, $\frac{1}{2}$ марафон: 1h 43m, 10k: 45m 40s)
\end{itemize}


}


\frame
{
\frametitle{Чего не будет в этом докладе}


\begin{itemize}
  \item TCS
  \item skip list
  \item treap
  \item Monte Carlo
  \item Local sensevity hashing
  \item etc.
\end{itemize}


}

\frame
{
\frametitle{Что будет в этом докладе}


Вероятностные структуры данных, которые позволяют экономить память.

Данных много. 

Храним мало, либо очень мало. 

Очень ограниченные задачи. 

Шаг вправо, шаг влево - попытка к бегству! Стреляем без предупреждения!
}




\frame
{
\frametitle{Предупреждение}

\epigraph{Надежность - это когда вашу программу ставят на военную технику, а вы спите спокойно}{\textit{Н. Н. Непейвода}}

\vspace{5mm}

Примечение: если от вашего кода зависит человеческая жизнь - одумайтесь.

}

\frame
{
\frametitle{Содержит сцены курения}

      \begin{figure}
        \includegraphics[height=0.55\textwidth]{killbill.jpg}
      \end{figure}
}


\frame
{
\frametitle{HyperLogLog}

Задача: 

\vspace{5mm}

\colorbox{gray!30}{select count(distinct(field)) from table}

\vspace{5mm}

От 10M, лучше от 100M. Eще больше. Значительно.

Иначе можно решаеть классическими способами.
}



\frame
{
\frametitle{HyperLogLog, идеальный мир}

Рассмотрим минимальный hash.

obj1, obj2, obj3, obj4, \ldots

0.672, 0.368, 0.864, 0.782, \ldots

Встретить 0.368 "более вероятно" чем 0.000001 (на 5-10 элементах).
}



\begin{frame}[fragile]
\frametitle{HyperLogLog}

Применим "шардинг" (простой roundRobin), будем считать min-hash для каждого подпотока.

  \begin{verbatim}
          a1, aN+1, ...         minHash
stream -> a2                    minHash
          ...                   ...
          aN                    minHash

  \end{verbatim}


\end{frame}

\begin{frame}[plain]

      \begin{figure}
        \includegraphics[height=0.8\textwidth]{hll_paper.png}
      \end{figure}
\end{frame}



\frame
{
\frametitle{HyperLogLog, random facts}

В кишках реализации используется количество 0 в префиксе hash-а. Log.
$$0.000001010111 \mapsto 5$$

Плюс набор предрасчитанных магических констант.

Где используется: 
во многих базах данных($redis, redshift, google bigquery$).

\colorbox{gray!30}{$select approx\_count(distinct(field)) from table$}

The HyperLogLog algorithm is able to estimate cardinalities of $> 10^9$ with a typical accuracy (standard error) of $2\%$, using 1.5 kB of memory. (original paper, wiki)

Распределенный подсчет HyperLogLog. 

}

\frame
{
\frametitle{HyperLogLog, stats}
      \begin{figure}
        \includegraphics[height=0.6\textwidth]{hll_stats.png}
      \end{figure}

}


\frame
{
\frametitle{HyperLogLog, use case}


Нужно ли где-то в простой жизни? 

Сетевое оборудование, считать количество уникальных src/dest соединений. 
Малое количество памяти, большое число объектов. 
Определение DDOS, "нечисти".

Запускать новый HLL, каждые 5 минут, TTL = 30 минут. 
Мониторить, если текущие значения отличаются от средних.

}


\frame
{
\frametitle{HyperLogLog, история}

LogLog -> HyperLogLog -> HyperLogLog+ (на 64-битах, уточнили набор магических констант)

Порядка 10 схожих алгоритмов/структур данных/вариаций.
}

\frame
{
\frametitle{Bloom filter}

Задача: 

проверка вхождения элемента во множество

Рассматриваем урезанную задачу, только ответ да/нет.
Задача перечисления, порядок добавления, возможность удаления сюда не входит.

Если объектов немного, то можно использовать hashTable, tree, set, etc.
}

\frame
{
\frametitle{Bloom filter, mini}

есть hashTable с 10 слотами, куда мы вставляем 3 объекта. С какой вероятностью будут коллизий?

TODO: картинка?

30-60 секунд на размышление... 

\pause

Итого:
$$1 - 1 * (9 / 10) * (8 / 10) = 1 - 0.72 = 0.28$$

Да, это та же задача что и в парадоксе дней рождения. 

\pause

Лайфхак: функция растет как $sqrt(n)$. 

Посчитать для int32, int64.
}

\frame
{
\frametitle{Bloom filter, perfect world}

Коллизии отсутствуют и бесконечная память.

Тогда бы хранили битовый флаг на бесконечной ленте. 
}

\frame
{
\frametitle{Bloom filter, real world}

Сделать несколько $k$ hash-functions на bitset размера $m$ при вставке $n$ объектов.

      \begin{figure}
        \includegraphics[height=0.3\textwidth]{bloom.png}
      \end{figure}


Один объект высталяет не один бит, а $k$ битов. 
Для проверки вхождения нужно проверить $k$ битов. Даже если все биты установлены, то это не гарантирует наличие объекта (false positive).

Confusion matrix.
}

\begin{frame}[plain]

      \begin{figure}
        \includegraphics[height=0.8\textwidth]{bloom_wiki.png}
      \end{figure}
\end{frame}


\frame
{
\frametitle{Bloom filter}

Посчитаем.

Оказывается, что все не так плохо. На каждые $10^{-3}$ ошибки требуется примерно 10 бит (бит, не байтов!).
То есть на $10^{-6}$ - 20 бит (2.5 байта), $10^{-9}$ - 30 бит (3.75 байта, все еще меньше одного указателя), и так далее.
Объекты - довольно жирные.

Внутри это всего лишь bitset. Нет никакого memory footprint.

То есть на 100M объектов с ошибкой $10^{-6}$ требуется 250Мб памяти.

"Минусы": исходная постановка урезана, нет "честной" возможности удалять, перечислять объекты.
}

\frame
{
\frametitle{Bloom filter}

Честность - относительна.

Удалять - завести второй bloomFilter, для удаленных. Делать 2 запроса. Нельзя "честно" удалить, а потом снова добавить.
Можно... Вы поняли идею
}


\frame
{
\frametitle{Bloom filter}

$$bloom_1 + bloom_2 = bit_or (bloom_1.internal_bitset, bloom_2.internal_bitset)$$

$$bloom_1 * bloom_2 = bit_and (bloom_1.internal_bitset, bloom_2.internal_bitset)$$

Spark example. 
$$Partition.map(x => Bloom()).reduce(\_ + \_)$$
$$Partition.map(x => Bloom()).reduce((x, y) => x + y)$$

Обратная задача. По bloomFilter понять сколько там элементов. 

См wiki.

}


\frame
{
\frametitle{Bloom filter, use cases}

Key-value storage.

Если кардинальность значений не велика $(k \le 10)$, то можно хранить $k$ bloom filter-ов. 
Спросить каждый. Учитывать, что ошибка меняется (* k).

}


\frame
{
\frametitle{Bloom filter, use cases}

Если кардинальность значений велика $(k > 10)$, то можно хранить $k$ bloom filter-ов.
Организовать дерево на них. 

\pause

\vspace{5mm}

На самом деле, это сложнее. Так как необходимо контролировать размеры и ошибку.
На домашнее задание.


      \begin{figure}
        \includegraphics[height=0.3\textwidth]{btree.png}
      \end{figure}


}


\frame
{
\frametitle{Bloom filter, use cases}


Телефонная база спамеров.
$+7-909-052-xx-yy$

Хранить на телефоне. 
В Int32 не влазит. Нужно отвечать да/нет в период звонка (до принятия). 
Гипотетически, $10^6$ "плохих" номеров.

Создать bloomFilter с ошибкой $p=10^{-9}$. Пробежаться во всему пространству номеров телефонов и явно выписать false Positive объекты.

На таких ограничениях есть много решений.
}


\frame
{
\frametitle{Bloom filter, use cases}

trie (цифровое дерево, префиксное дерево) - структура данных, хранящая префиксы слов.
Позволяет искать вхождение, и искать слова с заданным числом отпечаток.


      \begin{figure}
        \includegraphics[height=0.3\textwidth]{trie.png}
      \end{figure}

}



\frame
{
\frametitle{Bloom filter, use cases}

Предлагается хранить все префискы слов в bloomFilter. Все итоговые слова еще в одном bloomFilter.

"ключ", "ключница" 

В trie это обычно хранится булевым флагом, признак конца слова.

Чтобы спуститься на уровень вниз - переберем алфавит (либо доп. структуру, хранящую возможные переходы)

Оценка

Здесь же мы тратим 20-30 бит (1.5 - 3.75 байта) на узел.
}


\frame
{
\frametitle{Bloom filter, use cases}

Где используется в мире.

Почти в любом кеше и базе данных. Проще проверить в bloomFilter, и только потом читать с диска / делать тяжелый запрос.

Google guava (jvm).
TODO: обзор библиотек

TODO: compressed bloom filter
}

\frame
{
\frametitle{Count min sketch}

Задача: 
\colorbox{gray!30}{select count(*) from table where object = N}






}

\frame
{
\frametitle{Count min sketch}


      \begin{figure}
        \includegraphics[height=0.3\textwidth]{mins.png}
      \end{figure}

\pause

$$query = min_{i \in 1 \ldots k}(t_i(h_i))$$



}

\frame
{
\frametitle{Count min sketch}

Проблема перекоса данных, когда все ячейки в матрицы > 0.

Merge двух

Поэлементно сложить внутренний массив.
}








\frame
{
\frametitle{Desing, likes}

Пользователей - $10^9$, объектов - $10^9$. 

Всегда работает грубая сила "мы купили кластер на $100 - 1 K - 10 K$ нод и храним все".

Лайк - $(user_id, object_id)$. 

Да, bloomFilter на факт лайка/дизлайка. 

Количество лайков - классический KV, либо $Count-min-sketch(object_id)$.

Шардинг по $object_id, (user_id, object_id)$

Кто из друзей так же лайкал? Пробежаться по списку друзей, спросить bloomFilter.
Естественный граф ($natural\ graph$), особенности.

Отложенный лайк, если пользователь быстро передумал.
}


\frame
{
\frametitle{Desing, views}



}








\end{document}
